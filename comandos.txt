Sequência de comandos:

1. npm init -y
    -> Inicia o projeto node
_____    
2. npm install express
    -> instala o framework web express (ferramenta pra criar servidores e APIs em node)
_____
3. node --watch src/server.js
    -> Inicia a execução do servidor
_____
4. docker run --name projeto-docker-postgres -e POSTGRES_PASSWORD=admin -p 5432:5432 -d postgres
    -> Cria e inicia um conteiner docker para o banco de dados PostgreSQL
_____
5. docker ps
    -> Lista todos os containeres que estão em execução no momento. Usado pra verificar se o conteiner postgres subiu 
_____
6. npm install --save sequelize
    -> Instala o Sequelize, que é um ORM (Object-Relational mapper) para o node.
_____
7. npm install --save pg pg-hstore
    -> Instala os drivers do banco de dados necessários para o Sequelize se conectar ao postgres
_____
8. npm install sequelize-cli --dev
    -> Instala a ferramente de linha de comando do Sequelize. 
_____
9. npx sequelize-cli migration:generate --name create-users-table
    -> Usa a ferramenta do sequelize pra gerar um novo arquivo de migração. O nome do arquivo vai ser um timestamp (para garantir a ordem) seguido por create-users-table. Esse arquivo é onde define a estrutura (colunas, tipos, etc.) da tabela users
_____
10. npx sequelize-cli db:migrate
    -> Executa todas migrações pendentes. Ele lê o arquivo de migração que criamos e o aplica no banco de dados, criando a tabela users.
_____

===========================

No DOCKER tivemos que resolver erros que estavam acontecendo em diversas partes, então aqui ta o fluxo de como foi:

1. criamos os arquivos Dockerfile e docker-compose.yml
2. sudo apt install docker-compose
3. precisamos trocar a porta para 5433 pq a 5432 ja tava sendo usada
4. erro: KeyError: 'containerConfig' usamos: 
    docker-compose down -v --rmi all 
    terminal padrao: sudo systemctl restart docker e depois: docker-compose up --build
5. app_1 | ConnectionRefusedError [SequelizeConnectionRefusedError]: connect ECONNREFUSED ::1:5432
trocamos então no database.js: de localhost para db como é no docker-compose
6. db_1    | PostgreSQL Database directory appears to contain a database; Skipping initialization
usamos então: docker-compose down -v
e depois: docker-compose up --build
7. o log ainda mostrar Skipping initialization
usamos: docker-compose down
depois: sudo rm -rf postgres-data
depois: docker-compose up --build
8. ConnectionRefusedError
criamos: o arquivo wait-for-t.sh (para que a aplicação espere até que o banco de dados esteja realmente disponivel) 
no terminal quando criar o arquivo(e colocar o script dentro): chmod +x wait-for-it.sh
9. adicionar no package.json dentro do script o "dev" para rodar o npm run dev

resumo: 
1. fluxo inicial (passo 1-3)
2. KeyError: 'containerConfig' -> docker-compose down -v --rmi all
3. sudo systemctl restart docker
4. docker-compose up --build
5. ConnectionRefusedError -> trocar localhost por db
6. Skipping initialization (passo 6-7) -> docker-compose down -v 
sudo rm -rf postgres-data
docker-compose up --build
7. ConnectionRefusedError ("Race Condition") e psql: not found -> (criacao do script de espera) execucao do script no terminal chmod +x wait-for-it.sh
8. Missing script: "dev" -> editou o packege.json para adicionar "dev"
docker-compose up



comandos a partir de agora:
* docker-compose stop
* docker-compose start

* docker-compose up -> iniciar containeres a partir das imagens que ja existem
    - quando usar: quando para o projeto com stop ou down e nao fez nenhuma mudança de código

* docker-compose up --build -> constrói a imagem da aplicação (app) novamente e depois inicia todos os contêineres.
    - quando usar: quando faz alguma mudança no código ou adiciona uma nova dependência (npm install)

* docker-compose stop -> para os conteineres, mas os mantém salvos
    - quando usar: quando querer pausar o trabalho para liberar memória e CPU do computador, mas planeja voltar logo.

* docker-compose down -> para e remove os conteineres, redes e volumes
    - quando voce terminou o trabalho no projeto por um bom tempo, quer liberar espaço em disco, ou está fazendo uma mudança nas configurações do docker-compos.yml (como mudar portas ou volumes)